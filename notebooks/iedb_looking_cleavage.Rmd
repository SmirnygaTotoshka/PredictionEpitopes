---
title: "3. Поиск сайтов протеолиза белков протеосомой по данным IEDB"
author: "Антон Смирнов"
date: "24.01.2023"
link-citations: true
output: html_document
bibliography: references_look_iedb_cleavage.bib
---

# Введение

The Immune Epitope Database (IEDB)@vita2019 - крупнейшая база данных по Т и В-клеточным эпитопам. Необходимо оценить частоту встречаемости аминокислот на С-конце эпитопа, так как с него как правило не идет процессинг антигена для МНС 1 класса.

Установить соединение с БД, развернутой на локальном сервере.
```{r}
library(RMySQL)
library(dplyr)
library(stringr)
```


```{r}
con = RMySQL::dbConnect(RMySQL::MySQL(),
                            dbname='iedb',
                            host='localhost',
                            port=3306,
                            user='stotoshka',
                            password='meowmeow')
```

Типы экспериментов в БД.

```{sql connection=con}
SELECT category, count(category) FROM assay_type GROUP BY category;
```

Нам не нужны эксперименты с MHC и Naturally Processed, так как в них, как правило работают с линейными эпитопами и названия экспериментов соответствуют необходимым нам.

```{sql connection=con}
SELECT category, assay_type  FROM assay_type at2 WHERE category = 'MHC' ;
```

```{sql connection=con}
SELECT category, assay_type  FROM assay_type at2 WHERE category = 'Naturally Processed' ;
```

Необходимая нам информация содержится в таблицах mhc_elution и mhc_bind и связанных с ними.

```{sql connection=con}
SELECT DISTINCT at2.category,at2.assay_type FROM mhc_elution me 
INNER JOIN assay_type at2 ON as_type_id  = at2.assay_type_id;
```

```{sql connection=con}
SELECT DISTINCT at2.category,at2.assay_type FROM mhc_bind mb
INNER JOIN assay_type at2 ON as_type_id  = at2.assay_type_id 
```

# mhc_bind

Распределение по результатам

```{sql connection=con}
SELECT as_char_value, COUNT(as_char_value)  FROM mhc_bind GROUP BY as_char_value;
```


```{sql connection=con}
SELECT object_type, COUNT(object_type)  FROM object GROUP BY object_type;
```
```{sql connection=con}
SELECT object_sub_type, COUNT(object_sub_type)  FROM object GROUP BY object_sub_type;
```

Всего строк в таблице

```{sql connection=con}
SELECT COUNT(*) FROM mhc_bind;
```

Отфильтруем строки с пустыми полями

```{sql connection=con}
CREATE TABLE filtered_bind
AS (SELECT mhc_bind_id, reference_id, curated_epitope_id, as_char_value, mhc_allele_restriction_id 
    FROM mhc_bind
    WHERE mhc_bind_id IS NOT NULL AND
          reference_id IS NOT NULL AND
          curated_epitope_id IS NOT NULL AND
          as_char_value IS NOT NULL AND
          mhc_allele_restriction_id IS NOT NULL);
```

```{sql connection=con}
CREATE INDEX filtered_bind_index ON filtered_bind (mhc_bind_id,curated_epitope_id,mhc_allele_restriction_id);
```

Количество строк

```{sql connection=con}
SELECT COUNT(*) FROM filtered_bind;
```

# mhc_elution

Распределение по результатам

```{sql connection=con}
SELECT as_char_value, COUNT(as_char_value)  FROM mhc_elution GROUP BY as_char_value;
```

Всего строк в таблице

```{sql connection=con}
SELECT COUNT(*) FROM mhc_elution;
```

Отфильтруем строки с пустыми полями

```{sql connection=con}
CREATE TABLE filtered_elution
AS (SELECT mhc_elution_id, reference_id, curated_epitope_id, as_char_value, mhc_allele_restriction_id, h_organism_id, ant_type, ant_ref_name, ant_object_id, apc_cell_type, apc_tissue_type, apc_origin
    FROM mhc_elution
    WHERE mhc_elution_id IS NOT NULL AND
          reference_id IS NOT NULL AND
          curated_epitope_id IS NOT NULL AND
          as_char_value IS NOT NULL AND
          mhc_allele_restriction_id IS NOT NULL AND
          h_organism_id = 9606 AND
          ant_type = 'Epitope');
```

```{sql connection=con}
CREATE INDEX filtered_elution_index ON filtered_elution (mhc_elution_id,curated_epitope_id,mhc_allele_restriction_id);
```

Количество строк

```{sql connection=con}
SELECT COUNT(*) FROM filtered_elution;
```

Нам необходима информация о МНС и о эпитопе. Подготовим по отдельности и объединим.

# Эпитопы

```{sql connection=con}
SELECT DISTINCT COUNT(e_object_id) FROM curated_epitope;
```

```{sql connection=con}
SELECT e_region_domain_flag, COUNT(e_region_domain_flag) FROM curated_epitope
GROUP BY e_region_domain_flag;
```

```{sql connection=con}
SELECT e_ev, COUNT(e_ev) FROM curated_epitope
GROUP BY e_ev;
```

Фильтруем, чтобы не было пустых идентификаторов, был "Exact Epitope" и "Exact match to reference information", "Internal Identifier-no external match available", "Author provided Identifier".

```{sql connection=con}
CREATE TABLE filtered_epitope_cur
AS (SELECT curated_epitope_id, e_name, source_antigen_accession, description ,e_region_domain_flag, e_ev, linear_peptide_seq, e_ref_start,e_ref_end, `database`, name, sequence, organism_name
    FROM curated_epitope
    INNER JOIN epitope_object eo ON eo.object_id = e_object_id
    INNER JOIN epitope e ON e.epitope_id = eo.epitope_id
    INNER JOIN source s ON s.accession = source_antigen_accession
    WHERE e_region_domain_flag = 'Exact Epitope' AND
          linear_peptide_seq IS NOT NULL AND 
          linear_peptide_modification IS NULL AND
          sequence IS NOT NULL);
```

```{sql connection=con}
CREATE INDEX filtered_epitope_cur_index ON filtered_epitope_cur (curated_epitope_id);
```

```{sql connection=con}
SELECT COUNT(curated_epitope_id) FROM filtered_epitope_cur;
```

# MHC

```{sql connection=con}
SELECT COUNT(*) FROM mhc_allele_restriction;
```

```{sql connection=con}
SELECT restriction_level, COUNT(restriction_level) FROM mhc_allele_restriction
GROUP BY restriction_level;
```

```{sql connection=con}
SELECT class, COUNT(class) FROM mhc_allele_restriction
GROUP BY class;
```

Нам нужны человеческие (NCBI Taxonomy ID 9606) МНС 1 класса.

```{sql connection=con}
CREATE TABLE filtered_mhc
AS (SELECT mhc_allele_restriction_id, restriction_level,displayed_restriction, organism_ncbi_tax_id,class, chain_i_name
    FROM mhc_allele_restriction
    WHERE mhc_allele_restriction_id IS NOT NULL AND
          restriction_level = 'complete molecule' AND
          organism_ncbi_tax_id = 9606 AND
          class = 'I');
```
```{sql connection=con}
CREATE INDEX filtered_mhc_index ON filtered_mhc (mhc_allele_restriction_id);
```

```{sql connection=con}
SELECT COUNT(*) FROM filtered_mhc;
```

# BIND TOGETHER
mhc_bind_id, reference_id, as_char_value, 
e_name, source_antigen_accession, description ,e_region_domain_flag, e_ev, linear_peptide_seq, e_ref_start,e_ref_end, 'database', name, sequence, organism_name, 
restriction_level,displayed_restriction, organism_ncbi_tax_id,class, chain_i_name

```{sql connection=con}
CREATE TABLE epi_mhc_bind
AS (SELECT fb.mhc_bind_id, fb.reference_id, fb.as_char_value, 
e_name, source_antigen_accession, description ,e_region_domain_flag, e_ev, linear_peptide_seq, e_ref_start,e_ref_end, `database`, name, sequence, organism_name, 
restriction_level,displayed_restriction, organism_ncbi_tax_id,class, chain_i_name
    FROM filtered_bind fb
    INNER JOIN filtered_mhc fm ON fm.mhc_allele_restriction_id = fb.mhc_allele_restriction_id
    INNER JOIN filtered_epitope_cur fe ON fe.curated_epitope_id = fb.curated_epitope_id);
```
```{sql connection=con}
CREATE INDEX epi_mhc_bind_index ON epi_mhc_bind (mhc_bind_id);
```
```{sql connection=con}
SELECT COUNT(mhc_bind_id) FROM epi_mhc_bind;
```

```{sql connection=con}
CREATE TABLE epi_mhc_elution
AS (SELECT fel.mhc_elution_id, fel.reference_id, fel.as_char_value,
apc_cell_type, apc_tissue_type, apc_origin,
e_name, source_antigen_accession, description ,e_region_domain_flag, e_ev, linear_peptide_seq, e_ref_start,e_ref_end, `database`, name, sequence, organism_name, 
restriction_level,displayed_restriction, organism_ncbi_tax_id,class, chain_i_name
    FROM filtered_elution fel
    INNER JOIN filtered_mhc fm ON fm.mhc_allele_restriction_id = fel.mhc_allele_restriction_id
    INNER JOIN filtered_epitope_cur fe ON fe.curated_epitope_id = fel.curated_epitope_id);
```

```{sql connection=con}
CREATE INDEX epi_mhc_elution_index ON epi_mhc_elution (mhc_elution_id);
```

```{sql connection=con}
SELECT COUNT(mhc_elution_id) FROM epi_mhc_elution;
```

Combine

```{r echo=F}
bind.assays = RMySQL::dbReadTable(con, "epi_mhc_bind") %>% select(-mhc_bind_id)
elution.assays = RMySQL::dbReadTable(con, "epi_mhc_elution")%>% select(-one_of("mhc_elution_id","apc_cell_type","apc_tissue_type","apc_origin"))
all.assays = rbind.data.frame(bind.assays,elution.assays)
```
```{r}
sum(is.na(all.assays$reference_id))
```


```{r}
table(bind.assays$as_char_value)
```

```{r}
table(elution.assays$as_char_value)
```


```{r}
r = stringr::str_locate_all(bind.assays$sequence, bind.assays$linear_peptide_seq)
s = sapply(r,nrow)
match(s[s > 1],s)
r[1879]
bind.assays$linear_peptide_seq[1879]
substr(bind.assays$sequence[1879],354,363)
```

Берем С-концевые аминокислоты эпитопов и +1 после неё, разделив на положительные и отрицательные случаи

```{r}
neg.bind = subset.data.frame(bind.assays, as_char_value == "Negative")[,c("linear_peptide_seq","sequence")]
pos.bind = subset.data.frame(bind.assays, as_char_value != "Negative")[,c("linear_peptide_seq","sequence")]
neg.elution = subset.data.frame(elution.assays, as_char_value == "Negative")[,c("linear_peptide_seq","sequence")]
pos.elution = subset.data.frame(elution.assays, as_char_value != "Negative")[,c("linear_peptide_seq","sequence")]
```
```{r}
write.csv2(all.assays,"../data/source/all_assays.csv",row.names = F)
```

```{r}
locations = stringr::str_locate_all(all.assays$sequence, all.assays$linear_peptide_seq)

```
```{r}
C.terms = lapply(seq_along(locations),function(i, seq){
    str_sub(all.assays$sequence[i],locations[[i]][,"end"],locations[[i]][,"end"]+1)
})
```

```{r}
pairs = unlist(C.terms)
V1 = str_sub(pairs,1,1)
V2 = str_sub(pairs,2,2)
pairs.df = cbind.data.frame(V1,V2)
```

```{r}
print(round(table(pairs.df$V1) / nrow(pairs.df), 5))
plot(round(table(pairs.df$V1) / nrow(pairs.df), 5))
```

```{r}
round(table(pairs.df$V2) / nrow(pairs.df), 5)
```